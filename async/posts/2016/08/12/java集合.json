{"tags":[],"categories":[],"url":"/async/posts/2016/08/12/java集合.json","date":1471008148000,"path":{"year":2016,"month":8,"day":12,"name":"java集合"},"title":"","permalink":"http://yoursite.com/2016/08/12/java集合/","content":"<h1 id=\"java集合主要接口\"><a href=\"#java集合主要接口\" class=\"headerlink\" title=\"java集合主要接口\"></a>java集合主要接口</h1><h2 id=\"Iterator接口\"><a href=\"#Iterator接口\" class=\"headerlink\" title=\"Iterator接口\"></a>Iterator接口</h2><p>迭代器接口，该接口主要规范可迭代集合，通过实现该接口，可以迭代输出元素，该接口主要包含以下方法：</p>\n<ul>\n<li>boolean hasNext(); 是否有下一个元素</li>\n<li>E next(); 得到下一个元素</li>\n<li>boolean remove(); 删除当前元素</li>\n</ul>\n<h2 id=\"Iterable接口\"><a href=\"#Iterable接口\" class=\"headerlink\" title=\"Iterable接口\"></a>Iterable接口</h2><p>可迭代接口，实现该接口的类具有一个返回迭代器的功能，Collection接口继承自该接口，该接口主要包含以下方法:</p>\n<ul>\n<li>Iterator iterator(); 返回一个迭代器对象，通过迭代器对象可迭代输出元素</li>\n</ul>\n<h2 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h2><p>该接口是java集合的根接口，他提供了基本的元素操作方法，包括List,Set，Queue等子接口，主要包括以下方法：</p>\n<ul>\n<li>int size(); 返回集合的大小</li>\n<li>boolean isEmpty(); 判断集合是否空</li>\n<li>boolean contains(Object o); 判断集合是否包含某个元素</li>\n<li>Iterator<t> iterator(); 返回集合的迭代器对象</t></li>\n<li>boolean add(T t); 像集合中添加一个元素</li>\n<li>boolean remove(Object o); 移除集合中某一个元素</li>\n<li>containsAll(Collection&lt;?&gt; c); 判断是否完全包含另一个集合中所以元素</li>\n<li>addAll(Collection&lt;? extends E&gt; c); 将另一个集合中所有元素添加至本集合</li>\n<li>boolean removeAll(Collection&lt;?&gt; c); 将另一集合中所有元素从本集合移除</li>\n<li>void clear(); 清空集合元素</li>\n<li>boolean equals(Object o); equals方法，强制实现类重写</li>\n<li>int hashCode(); hashCode方法，强制实现类重写</li>\n<li>boolean retainAll(Collection&lt;?&gt; c); 仅保留此collection中那些也包含在指定collection的元素</li>\n</ul>\n<h2 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h2><p>该接口定义的元素是有序的且可重复的。相当于数学里面的数列，有序可重复</p>\n<ul>\n<li>boolean addAll(int index, Collection&lt;? extends E&gt; c); 将指定集合中所有元素，插入至本集合第index个元素之后</li>\n<li>default void replaceAll(UnaryOperator<e> operator); 替换集合中每一个元素值</e></li>\n<li>default void sort(Comparator&lt;? super E&gt; c); 给集合中的元素进行排序</li>\n<li>E get(int index); 获取集合中第index个元素</li>\n<li>E set(int index, E element); 将集合中第index个元素替换成指定元素</li>\n<li>void add(int index, E element); 向集合中第index个位置添加一个元素</li>\n<li>E remove(int index); 移除集合中第index个元素</li>\n<li>int indexOf(Object o); 得到指定元素在集合中的位置（第一次出现）</li>\n<li>int lastIndexOf(Object o); 得到指定元素在集合中的位置（最后一次出现）</li>\n<li>ListIterator<e> listIterator(); 返回ListIterator</e></li>\n<li>ListIterator<e> listIterator(int index); 返回ListIterator,并设置当前位置</e></li>\n<li>List<e> subList(int fromIndex, int toIndex); 截取List，从fromIndex到toIndex</e></li>\n</ul>\n<h2 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h2><p>该接口定义的集合不允许包含重复的元素，更严格的来说是两个元素的equals方法。且该集合中的元素是无序的。该接口相当于数学中的集合，元素不可重复且无序。</p>\n<h2 id=\"Queue接口\"><a href=\"#Queue接口\" class=\"headerlink\" title=\"Queue接口\"></a>Queue接口</h2><p>该接口用以实现队列功能（先进先出），队列中增加、删除、获取都包含两组方法，一组方法抛出异常，一组方法返回false或者null，该接口主要包含以下方法:</p>\n<ul>\n<li>boolean add(E e); 像队列中插入一个元素，队列满时抛出异常</li>\n<li>boolean offer(E e); 像队列中插入一个元素，队列满时返回false</li>\n<li>E remove(); 获得并移除队列顶部元素，如果队列为空抛出异常</li>\n<li>E poll(); 获得并移除队列顶部元素，如果队列为空返回null</li>\n<li>E element(); 获得队列顶部元素，不会删除队列顶部元素，队列为空时抛出异常</li>\n<li>E peek();获得队列顶部元素，不会删除队列顶部元素，队列为空时返回null</li>\n</ul>\n<h1 id=\"Collection子类\"><a href=\"#Collection子类\" class=\"headerlink\" title=\"Collection子类\"></a>Collection子类</h1><h2 id=\"AbstractCollection抽象类\"><a href=\"#AbstractCollection抽象类\" class=\"headerlink\" title=\"AbstractCollection抽象类\"></a>AbstractCollection抽象类</h2><p>该类实现了基本的集合功能，主要包括如下：</p>\n<ul>\n<li>boolean isEmpty(); 判断集合是否空，调用集合的size方法判断</li>\n<li>boolean contains(Object o); 判断集合是否包含某个元素，内部调用迭代器迭代实现</li>\n<li>Object[] toArray(); 将集合元素转换成数组，内部调用迭代器迭代元素，保存至数组中</li>\n<li><t> T[] toArray(T[] a); 将集合元素转换成数组，内部调用迭代器迭代元素，保存至数组中</t></li>\n<li>boolean add(E e); 添加元素方法，内部直接抛出异常，如果子类需要使用add方法，需要重写</li>\n<li>boolean remove(Object o); 移除元素，内部使用迭代器实现</li>\n<li>boolean containsAll(Collection&lt;?&gt; c); 遍历c，内部使用contains(obj)实现</li>\n<li>boolean addAll(Collection&lt;? extends E&gt; c); 添加集合c中所有元素，内部调用add方法</li>\n<li>boolean removeAll(Collection&lt;?&gt; c); 移除集合c中所有元素，内部使用迭代器删除</li>\n<li>boolean retainAll(Collection&lt;?&gt; c); 只保留集合c中元素，内部使用迭代器实现</li>\n<li>void clear(); 清空集合中的元素，内部使用迭代器实现</li>\n<li>String toString(); 该抽象类重写了toString方法，内部使用[元素，元素]格式输出元素，所以我们可以通过此方法打印集合的内容</li>\n</ul>\n<h1 id=\"List子类\"><a href=\"#List子类\" class=\"headerlink\" title=\"List子类\"></a>List子类</h1><h2 id=\"AbstractList抽象类\"><a href=\"#AbstractList抽象类\" class=\"headerlink\" title=\"AbstractList抽象类\"></a>AbstractList抽象类</h2><p>该类实现了基本的List集合功能，如果实现的是只读的List集合，继承自该抽象类的子类只需要实现get(int index)和size()两个方法，如果是可操作的List集合，则必须重写add和set方法，否则执行add和set时会抛出UnsupportedOperationException异常<br>AbstractList抽象类中的迭代器通过get(int index)访问元素，通过remove(Object o)删除元素。<br>AbstractList抽象类包含了一个SubList子类，该子类通过包装一个AbstractList抽象类对象实现元素的添加、删除等功能。<br>该抽象类主要实现了如下方法：</p>\n<ul>\n<li>boolean add(E e); 添加元素e，内部调用add(int index,E element)实现</li>\n<li>int indexOf(Object o); 得到指定元素第一次在集合中的位置，内部通过List迭代器实现</li>\n<li>int lastIndexOf(Object o); 得到指定元素在集合中的位置（最后一次出现），内部List迭代器实现，注意此处是从后往前迭代</li>\n<li>void clear(); 清空List集合中的元素，内部通过List迭代器实现</li>\n<li>boolean addAll(int index, Collection&lt;? extends E&gt; c); 插入集合c中所有元素，内部调用add(int index,E element)实现</li>\n<li>Iterator<e> iterator(); 返回一个迭代器对象，AbstractList抽象类内部实现了一个迭代器</e></li>\n<li>ListIterator<e> listIterator(); 返回一个List迭代器对象，AbstractList抽象类内部实现了一个List迭代器</e></li>\n<li>boolean equals(Object o); 重写Object的equals方法，内部先判断是否同一个对象，是返回true，否则判断o是否是List对象，不是返回false，是的话迭代比较两个集合中每一个元素是否一致，都一致返回true</li>\n<li>int hashCode(); 内部迭代集合中每一个元素计算出hashcode值</li>\n<li>List<e> subList(int fromIndex, int toIndex);得到List集合的子集合，内部通过构造AbstractList内部的SubList实现</e></li>\n</ul>\n<h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p>ArrayList继承自AbstractList实现了List中所有方法，该集合可以插入任何元素包括null元素。<br>ArrayList内部使用数组保存元素，他的size、isEmpty、get、set、add等操作都是常数时间。在获取元素时会比LinkedList更有优势。<br>Arraylist有一个初始的大小，该大小会随着元素的增加而增长。<br>ArrayList不是线程安全的，在多线程环境下使用时需要注意，我们可以通过Collections.synchronizedList(new ArrayList(…));操作得到一个线程安全的ArrayList<br>ArrayList中的迭代器在List集合结果变化后，我们调用迭代器中的方法时会快速抛出ConcurrentModificationException异常通知程序，以免造成损失。<br>ArrayList的扩展策略：<br>在初始集合为空时，加入元素时会初始化Math.max(DEFAULT_CAPACITY, minCapacity)个空间，即取插入元素个数和DEFAULT_CAPACITY中比较大的那个数<br>集合非空时插入元素，如果空间不够时，则取原集合大小扩展2倍和最小需求大小中较大的那个进行扩展<br>ArrayList重写了Iterator和ListIterator，内部直接通过遍历数组实现<br>ArrayList重写了SubList类，该类直接通过访问数组实现<br>ArrayList主要包括以下属性：</p>\n<ul>\n<li>transient Object[] elementData; 该对象数组用于存放集合中的元素</li>\n<li>int size; 该属性用于保存集合的大小</li>\n<li>transient int modCount; 记录ArrayList修改的次数，在集合迭代器中会使用该数字判断迭代时集合是否修改过<br>ArrayList主要包含以下构造函数：</li>\n<li>ArrayList(int initialCapacity); 构造初始大小为initialCapacity的集合对象</li>\n<li>ArrayList(); 构造一个空的数组元素</li>\n<li>ArrayList(Collection&lt;? extends E&gt; c); 使用传入集合c构造一个集合对象<br>ArrayList主要包括以下函数：</li>\n<li>void trimToSize(); 将集合中数组大小恢复至当前集合大小，该操作可以压缩集合使用空间</li>\n<li>void ensureCapacity(int minCapacity); 通过传入的minCapacity判断集合是否需要扩展，需要的话则扩展数组大小，已足够存放元素</li>\n<li>int indexOf(Object o); 得到指定元素第一次在集合中的位置,重写了AbstractList类的方法，内部直接遍历元素数组实现</li>\n<li>int lastIndexOf(Object o); 同上</li>\n<li>Object clone(); 重写了clone方法，并且将元素数组复制一份出来，且将modCount致0，注意此处数组中元素并没有clone，也就是说克隆后的集合和元集合使用同一份具体元素</li>\n<li>Object[] toArray(); 直接返回本集合中的数组</li>\n<li>E get(int index); 直接访问数组</li>\n<li>E set(int index, E element); 直接设置数组元素值</li>\n<li>boolean add(E e); 直接操作数组，想数组添加一个元素</li>\n<li>E remove(int index); 直接操作数组</li>\n<li>boolean remove(Object o); 一样遍历数组，注意该操作会导致数组移动</li>\n<li>void clear(); 遍历将数组致空，同时设置size大小为0</li>\n<li>boolean addAll(Collection&lt;? extends E&gt; c); 通过数组直接添加</li>\n<li>void sort(Comparator&lt;? super E&gt; c); 实现集合中元素排序功能，接收一个Comparator用以比较集合中元素的大小</li>\n</ul>\n"}